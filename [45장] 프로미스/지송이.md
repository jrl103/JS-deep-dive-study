#45장 프로미스
=================================================================

- 자바스크립트는 비동기 처리를 위한 하나의 패턴으로 `콜백 함수`를 사용함
  - 콜백 패턴 : 콜백 헬로 인해 `가독성 나쁘고` + `에러 처리 곤란` + 여러 개의 비동기 처리를 `한 번에 처리할 때 한계 O`
- ES6 : 비동기 처리를 위한 또 다른 패턴 프로미스(Promise) 도입
  - 전통적인 `콜백 패턴이 가진 단점 보완` + `비동기 처리 시점을 명확하게 표현`할 수 있다는 장점


# 45-1. 비동기 처리를 위한 콜백 패턴의 단점

## 45-1-1. 콜백 헬

````javascript
// GET 요청을 위한 비동기 함수
const get = url => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();
    
    xhr.onload = () => {
        if (xhr.status === 200) {
            // 서버의 응답을 콘솔에 출력
            console.log(JSON.parse(xhr.response));
        } else {
            console.error(`${xhr.status} ${xhr.statusText}`);
        }
    };
};

// id 가 1인 post 를 취득
get('https://jsonplaceholder.typicode.com/posts/1');

/*
{
 "userId": 1,
 "id": 1,
 "title": "sunt aut facere ...",
 "body": "quia et suscipit ..."
}
*/
````

- get 함수 : 비동기 함수
- 비동기 함수 : 함수 내부에 비동기로 동작하는 코드를 포함한 함수

#### 비동기 함수를 `호출`하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도, 기다리지 않고 `즉시 종료`됨
#### 즉, `비동기 함수 내부의 비동기로 동작하는 코드`는 `비동기 함수가 종료된 이후에 완료`됨
#### so, `비동기 함수 내부의 비동기로 동작하는 코드`에서 `처리 결과를 외부로 반환`하거나, `상위 스코프의 변수에 할당`하면 기대한 대로 `동작 X`

예를 들어,
- setTimeout 함수 = 비동기 함수
  - 콜백 함수의 호출이 비동기로 동작하기 때문
  - setTimeout 을 호출하면, 콜백 함수를 호출 스케줄링한 다음, 타이머 id 를 반환 + 즉시 종료
- 즉, 비동기 함수인 setTimeout 함수의 콜백 함수는 setTimeout 함수가 종료된 이후에 호출됨
- so, setTimeout 함수 내부의 콜백 함수에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작 X


- setTimeout 함수의 콜백 함수에서 상위 스코프에 변수의 값을 할당해보자
- setTimeout 함수는 생성된 타이머를 식별할 수 있는 고유한 타이머 id 를 반환하므로 콜백 함수에서 값을 반환하는 것은 무의미


```javascript
let g = 0;

// 비동기 함수인 setTimeout 함수는 콜백 함수의 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당 X
setTimeout(() => { g = 100 }, 0);
console.log(g); // 0
```

### get 함수
- `비동기 함수`
- GET 요청을 전송하고 서버의 응답을 전달받음
- 비동기 함수인 이유
  - get 함수 내부의 `onload 이벤트 핸들러가 비동기로 동작`하기 때문
- `호출`하면 GET 요청을 전송하고 `onload 이벤트 핸들러를 등록`한 다음 + `undefined 를 반환` + 즉시 종료
  - so, get 함수의 onload 이벤트 핸들러에서,
  - 서버의 응답 결과를 반환하거나 상위 스코프의 변수에 할당하면 제대로 동작 X


get 함수가 서버의 응답 결과를 반환하도록 수정해 보자

```javascript
// GET 요청을 위한 비동기 함수
const get = url => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();
    
    xhr.onload = () => {
        if (xhr.status === 200) {
            // 1. 서버의 응답을 반환
          return JSON.parse(xhr.response);
        }
        console.error(`${xhr.status} ${xhr.statusText}`);
    };
};

// 2. id 가 1 인 post 를 취득
const response = get('https://jsonplaceholder.typicode.com/posts/1');
console.log(response);  // unedfined 반환 :: 명시적인 반환문이 없으므로
```

- get 함수가 호출되면 XMLHttpRequest 객체를 생성 + HTTP 요청 초기화 + HTTP 요청 전송
- xhr.onload 이벤트 프로퍼티에 이벤트 핸들러를 바인딩 + 종료
  - 이때 get 함수에 명시적인 반환문이 없으므로, `get 함수는 undefined 를 반환함(2)`


- xhr.onload 이벤트 핸들러 프로퍼티에 바인딩한 이벤트 핸들러의 반환문(1)
  - get 함수의 반환문 X
  - 암묵적으로 undefined 를 반환
- `함수의 반환값은 명시적으로 호출한 다음에 캐치할 수 있으므로`,
  - onload 이벤트 핸들러를 get 함수가 호출할 수 있다면
  - 이벤트 핸들러의 반환값을 get 함수가 캐치하여 다시 반환할 수도 있겠지만
  - onload 이벤트 핸들러는 get 함수가 호출하지 않기 때문에 그럴 수도 X


- 서버로부터 응답이 xhr 객체에서 load 이벤트가 발생함
#### 이때 xhr.onload 핸들러 프로퍼티에 바인딩한 `이벤트 핸들러가 즉시 실행되는 것이 X`
#### xhr.onload 이벤트 핸들러는 load 이벤트가 발생하면 일단 `태스크 큐에 저장되어 대기`하다가,
#### `콜 스택이 비면 이벤트 루프에 의해 콜 스택으로 푸시되어 실행됨`


#### 이처럼 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수 X
#### so, `비동기 함수의 처리 결과(서버의 응답 등)` 에 대한 후속 처리는 `비동기 함수 내부에서 수행`해야 함
#### 이때 비동기 함수를 범용적으로 사용하기 위해, 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행하는 `콜백 함수를 전달하는 것이 일반적`임
#### 필요에 따라 비동기 처리가 성공하면 호출될 콜백 함수와 비동기 처리가 실패하면, 호출될 콜백 함수를 전달할 수 있음

- 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출
  - `콜백 헬(callback hell)`
  - 콜백 함수 호출이 `중첩`되어 복잡도가 높아지는 현상

## 45-1-2. 에러 처리의 한계

비동기 처리를 위한 콜백 패턴의 문제점 중에서 가장 심각한 것 : 에러 처리가 곤란하다는 것

```javascript
try {
    setTimeout(() => { throw new Error('Error!') }, 1000 );
} catch (e) {
    // 에러를 캐치하지 못한다
  console.error('캐치한 에러', e)
}
```

> [ try ... catch ... finally 문 ]
> - 에러 처리를 구현하는 방법
> - 이 문으로 에러를 처리하면 프로그램이 강제 종료되지 않는다.


#### 에러는 호출자(caller) 방향으로 전파됨

- 즉, `콜 스택의 아래 방향`(실행 중인 실행 컨텍스트가 푸시되기 `직전에 푸시된 실행 컨텍스트 방향`) 으로 전파됨
- but, setTimeout 함수의 콜백 함수를 호출한 것은 setTimeout 함수 X
  - so, `setTimeout 함수의 콜백 함수가 발생시킨 에러는 catch 블록에서 캐치되지 X`

# 45-2. 프로미스의 생성

- `Promise 생성자 함수`를 new 연산자와 함께 호출하면 `프로미스(Promise 객체)` 를 생성
- ES6 에서 도입된 Promise 는 호스트 객체가 아닌 `ECMAScript 사양에 정의된 표준 빌트인 객체`



### Promise 생성자 함수
  - 비동기 처리를 수행할 `콜백 함수`(ECMAScript 사양에서는 executor 함수라고 부름) 를 인수로 전달받음
    - 이 콜백 함수는 r`esolve 와 reject 함수를 인수로 전달받음`

```javascript
// 프로미스 생성
const promise = new Promise((resolve, reject) => {
    // Promise 함수의 콜백 함수 내부에서 비동기 처리를 수행함
  if (/* 비동기 처리 성공*/) {
      resolve('result');
  } else (/* 비동기 처리 실패*/) {
      reject('failure reason');
  }
});
```

앞에서 살펴본 비동기 함수 get 을 프로미스를 사용해 구현해보자

````javascript
// GET 요청을 위한 비동기 함수
const promiseGet = url => {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();
        
        xhr.onload = () => {
            if (xhr.status === 200) {
                resolve(JSON.parse(xhr.response));
            } else {
                reject(new Error(xhr.status));
            }
        };
    });
};

// promiseGet 함수는 프로미스를 반환한다.
promiseGet('https://jsonplaceholder.typicode.com/posts/1');
````

| 프로미스의 상태 정보 | 의미                    | 상태 변경 조건           |
|:------------|:----------------------|:-------------------|
| pending     | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |          
| fulfilled   | 비동기 처리가 수행된 상태(성공)    | resolve 함수 호출      | 
| rejected    | 비동기 처리가 수행된 상태(실패)    | reject 함수 호출       |


비동기 처리 성공
: resolve 함수를 호출해 프로미스를 fulfilled 상태로 변경

비동기 처리 실패
: reject 함수를 호출해 프로미스를 reject 상태로 변경

#### 프로미스의 상태는 resolve 또는 reject 함수를 호출하는 것으로 결정됨












