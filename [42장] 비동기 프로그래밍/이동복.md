# 42장 비동기 프로그래밍

## 42.1 동기 처리와 비동기 처리

- 함수를 호출하면 함수 코드가 평가되고 함수 실행 컨텍스트가 생성되며 실행 컨텍스트 스택(=콜 스택) 에 push된다. (그 후 함수 코드 실행)
- 함수 실행이 종료되면 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 pop되어 제거된다.

```javascript
const foo = () => {};
const bar = () => {};

foo();
bar();

// 전역 실행 컨텍스트 위로 foo 함수 실행 컨텍스트가 push 된다.
// foo 함수 실행 컨텍스트가 실행 후 종료되고 pop된다.
// bar 함수 실행 컨텍스트가 push되고 마찬가지로 pop된다.
// 마지막으로 전역 실행 컨텍스트가 pop된다.
```

- 실행 컨텍스트 스택에 함수 실행 컨텍스트가 push되는 것은 함수 실행을 의미한다.
- 함수 호출 순서대로 순차적으로 실행되는 이유가 이 때문이다.
- 자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 가지고 있어 한 번에 하나의 태스크만 실행되는 싱글 스레드 방식으로 동작한다.
- 하나의 태스크씩 실행, 처리되는 이유는 블로킹(작업 중단)이 발생하기 때문이다.

```javascript
function sleep(func, delay) {
	const delayUntil = Date.now() + delay;
	
	while (Date.now() < delayUntil);
	
	func();
}

function foo() {
	console.log('foo');
}

funciton bar() {
	console.log('bar');
}

sleep(foo, 3 * 1000);

// 3초 대기 후 foo 함수 호출 후 bar함수 호출
// foo함수 호출부터 실행 종료까지가 blocking 시간이다.
bar();

// sleep 함수 대체
// 대기시간을 가지지 않고 'bar' 이후 'foo' 출력
blocking이 발생하지 않는 비동기 처리
setTimeout(foo, 3 * 1000); 
```

- setTimeout 함수 이후 태스크는 블로킹되지 않고 바로 실행된다. (비동기 처리 방식)
- 동기 처리는 순서가 보장되는 대신 블로킹이 발생한다.
- 비동기 처리는 반대의 장단점을 갖는다.
- 비동기 함수는 콜백 패턴을 사용한다.
- 콜백 헬은 가독성을 떨어뜨리며 비동기 처리 중 예외 처리가 곤란하다. 여러 개의 비동기 처리를 한 번에 처리하는 것에도 한계를 가진다.
- setTimeout, setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리방식으로 동작한ㄷ.(이벤트 루프, 태스크 큐에 관계가 있다.)

## 42.2 이벤트 루프와 태스크 큐에

- 자바 스크립트는 싱글 스레드로 동작하지만 브라우저는 여러 개의 태스크가 동시에 처리되는 것처럼 보인다.
- 자바스크립트의 동시성을 지원하는 것은 이벤트 루프이다.

### 자바스크립트 엔진은 2개의 영역으로 구분 가능하다.

1. 콜 스택
- 소스코드(전역 코드, 함수코드 등) 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택.
- 함수 호출 시 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되고 순차적으로 실행된다. JS 엔진은 하나의 콜 스택을 사용하여 최상위 실행 컨텍스트(실행 중인 실행 컨텍스트) </br>
가 종료되어 콜 스택에서 제거되기 전까지 다른 태스크는 실행되지 않는다.

2. 힙 
- 객체가 저장되는 메모리 공간으로  콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.
- 메모리에 값을 저장하려면 값을 저장할 메모리 공간의 크기가 결정되어야 한다.
- 객체는 원시 값과 달리 크기가 정해져 있지 않아 할당할 메모리 공간의 크기를 런타임에 동적 할당 해야한다. 따라서 힙은 구조화되어 있지 않다.

> 비동기 처리에서 솟코드의 평가와 실행을 제외한 모든 처리는 JS 엔진 환경인 브라우저 또는 Node.js가 담당한다.
>> 즉, 호출 스케줄링의 타이머 설정, 콜백 함수 등록은 브라우저 또는 Node.js가 담당하고 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.

3. 태스크 큐
- setTimeout, setInterval 등 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.
- 태스크 큐와 별로도 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐도 존재한다.

4. 이벤트 루프
- 콜 스택에 현재 실행 중인 실헌 컨텍스트 확인, 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)의 존재를 반복해서 확인한다.
- 만약 콜 스택이 비어쏙 태스크 큐에 대기 중인 함수가 있으면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.
- 이 때 이동된 함수는 실행된다. (태스크 큐에 일시적으로 보관된 함수들은 비동기 처리 방식으로 동작한다.)

```javascript
function foo() {// ...}
function bar() {// ...}

setTimeout(foo, 0); // 0초 (실제 4ms) 후 foo 함수 호출
bar();

// 1. 전역코드 평가 후 전역 실행 컨텍스트 생성하여 콜 스택에 푸시
// 2. 전역 코드가 실행되며 setTimeout 함수 호출. 이 때 setTimeout 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다.
// 브라우저의 Web API(호스트 객체)인 타이머 함수도 함수이므로 함수 실행 컨텍스트를 생성한다.
// 3. setTimeout 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 팝된다. 이 때 타이머 설정과 타이머가 만료되면 콜백 함수를 태스크 큐에 푸시한다.(브라우저의 역할)
// 4. 브라우저가 수행하는 4-1과 JS엔진이 수행하는  4-2는 병행 처리된다.
// 4-1. 브라우저는 타이머를 설정하고 만료를 기다린다. 타이머 만료 후 콜백 함수 foo가 태스크 큐에 푸시된다. 예제에서 지연시간 0이지만 4ms 이하는 4ms 가 지정된다.
// 4ms 후 콜백 함수 foo가 태스크 큐에 푸시되어 대기한다. (브라우저가 수행)
// 함수 스케줄링된 콜백 함수는 지연 시간 이후 호출된다는 보장이 없다. 콜 스택이 비어야 호출되기 때문이다.
// 4-2. bar 함수가 호출되어 bra함수의 함수 실행 컨텍스트 생성 후 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다.
// 이후 bar 함수가 종료되어 콜 스택에서 팝된다. 브라우저가 타이머를 설정한 후 4ms가 경과하면 foo함수는 아직 태스크 큐에 대기 중이다.
// 5. 전역 코드 실행이 종료되고 잔역 실행 컨텍스트가 콜 스택에서 팝된다. 콜 스택에는 아무런 실행 컨텍스트도 존재하지 않게 된다.
// 6. 이벤트 루프에 의해 콜 스택이 비어 있음이 감지되면 태스크 큐에서 대기 중인 콜백 함수 foo가 이벤트 루프에 의해 콜 스택에 푸시되고 종료되어 팝된다.
```

- 비동기 함수인 setTimeout 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면(함수가 모두 종료되면) 콜스택에 푸시되어 실행된다.
- JS는 싱글 스레드 방식이지만 브라우저가 아닌 브라우저에 내장된 JS엔진이다.
- 만약 모든 JS 코드가 JS 엔진에서 싱글 스레도르 동작하면 JS는 비동기로 동작 불가능하다.
- JS엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다.
